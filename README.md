# redis_lock
redis分布式锁

## 分布式锁
- JVM层面的加锁，是单机版的锁
- 分布式微服务架构，拆分后各个微服务之间为了避免冲突和数据故障而加入的一种锁，分布式锁
这是两种不同的东西

## 哪些技术可以实现分布式锁
- mysql
- zookeeper
- redis

## 分布式锁使用场景
多个服务间 + 保证同一时刻内 + 同一个用户只能有一个请求(防止关键业务出现数据冲突和并发错误)

## 问题1
- 没有加锁，并发下数字不对，出现超卖现象
- 加锁
  -  加synchronized
  -  加ReentrantLock
  -  还是都可以
  -  分析
  
 加synchronized - 下死命令  
 ReentrantLock - 我等着觉得时间太长了，我想放弃等待；给我一个规定的时间内，拿不到锁我再放弃
 
 ## 问题2
 -  分布式部署后，单机锁还是出现超卖现象，需要分布式锁
 -  nginx配置负载均衡
 -  结果：使用压测出现超卖现象
 -  改进：使用redis分布式锁setnx
 
## 问题3
-  出异常的话可能无法释放锁，必须要在代码层面finally释放锁

## 问题4
-  部署了微服务jar包的机器挂了，代码层面根本没有走到finally这块，没办法保证解锁，这个key没有被删除，需要加入一个过期时间限定
-  解决：需要对lockKey有过期时间的限定

## 问题5
- 设置key+过期时间分开了，必须要合并成一行

## 问题6
-  张冠李戴，删除了别人的锁

## 问题7
- finally块的判断 + del 删除操作不是原子的

## 问题8
- 确保RedisLock过期时间大于业务执行时间的问题
- redis分布式锁如何续期

## 总结
synchronized 单机版OK(分布式锁不OK)  
Nginx分布式微服务单机锁不行  
取消单机锁，上redis分布式锁setnx  
只加了锁，没有释放锁。出问题的话，可能无法释放锁，必须要在代码层面finally释放锁  
宕机了，部署了微服务层面根本没有走到finally这块，没办法保证解锁，这个key没有被删除，需要有lockKey的过期时间  
为redis的分布式锁，增加过期时间，此外，还必须要setnx + 过期时间要同一行  
必须规定只能删除自己的锁，你不能把别人的锁删除了，防止张冠李戴。1删2,2删3  
redis集群环境下，我们自己写的也不OK，直接上RedLock之Redission落地实现

 